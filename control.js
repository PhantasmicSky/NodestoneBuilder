var skillData = {"Adele":["Blade of Will","Magic Dispatch","Skewering","Impale","Aether Forge","Eviscerate","Reign of Destruction","Cleave","Hunting Decree","Aether Bloom"],"Angelic Buster":["Soul Buster","Star Bubble","Lovely Sting","Pink Pummel","Soul Seeker","Shining Star Burst","Heavenly Crash","Celestial Roar","Trinity","Finale Ribbon","Soul Resonance","Supreme Supernova"],"Aran":["Smash Wave","Smash Swing","Final Charge","Final Attack","Final Toss","Rolling Spin","Judgment Draw","Gathering Hook","Final Blow","Beyond Blade","Finisher - Storm of Fear","Finisher - Hunter's Prey","Maha's Domain"],"Ark":["Overcharge Drive","Ominous Nightmare","Scarlet Charge Drive","Unstoppable Impulse","Impending Death","Gust Charge Drive","Abyssal Charge Drive","Endless Agony"],"Battle Mage":["Triple Blow","Condemnation","Quad Blow","Dark Chain","Quintuple Blow","Battle Burst","Dark Shock","Finishing Blow","Dark Genesis","Sweeping Staff"],"Beast Tamer":["Paw Swipe","Deep Breath","Really Deep Breath","Li'l Fort","Fishy Slap","Table Flip","Leopard's Paw","Macho Dance","Thunder Dash","Three-Point Pounce","Party Time","Formation Attack","Tornado Flight","Friend Launcher","Fire Kitty!","Group Bear Blaster"],"Bishop":["Heal","Holy Arrow","Shining Ray","Big Bang","Bahamut","Angel Ray","Genesis","Heaven's Door"],"Blaster":["Magnum Punch","Revolving Cannon","Bunker Buster Explosion","Detonate","Double Blast","Hammer Smash","Rocket Rush","Shotgun Punch","Muzzle Flash","Ballistic Hurricane","Revolving Blast","Hyper Magnum"],"Blaze Wizard":["Orbital Flame","Flame Bite","Flame Vortex","Orbital Explosion","Flame Tempest","Cinder Maelstrom","Blazing Extinction","Towering Inferno","Cataclysm","Phoenix Drive"],"Bowmaster":["Arrow Blow","Final Attack","Wind Arrow","Phoenix","Covering Fire","Arrow Blaster","Hurricane","Arrow Stream","Quiver Cartridge","Gritty Gust"],"Buccaneer":["Sea Serpent Burst","Static Thumper","Turning Kick","Corkscrew Blow","Sea Serpent's Rage","Octopunch","Nautilus Strike","Hook Bomber"],"Cadena":["Reign of Chains","Summon Scimitar","Summon Daggers","Summon Shotgun","Summon Brick","Beatdown","Summon Spiked Bat","Veteran Shadowdealer"],"Cannoneer":["Cannon Blaster","Cannon Strike","Blast Back","Scatter Shot","Barrel Bomb","Cannon Spike","Cannon Jump","Barrel Roulette","Monkey Fury","Cannon Bazooka","Nautilus Strike","Anchors Away","Monkey Militia","Cannon Barrage","Rolling Rainbow"],"Corsair":["Rapid Blast","Recoil Shot","Scurvy Summons","Blunderbuster","Blackboot Bill","Siege Bomber","Rapid Fire","Nautilus Strike","Brain Scrambler","Eight-Legs Easton","Majestic Presence","Broadside","Parrotargetting","Ugly Bomb"],"Dark Knight":["Final Attack","Spear Sweep","La Mancha Spear","Rush","Evil Eye","Dark Impale","Gungnir's Descent","Nightshade Explosion"],"Dawn Warrior":["Solar Slash","Cosmic Matter","Cosmic Shower","Bluster","Cosmic Burst","Impaling Rays","Equinox Slash","Blazing Assault"],"Demon Avenger":["Exceed Double Slash","Exceed Demon Strike","Bat Swarm","Exceed Lunar Slash","Vitality Veil","Shield Charge","Exceed Execution","Nether Shield","Nether Slice","Blood Prison","Thousand Swords","Infernal Exceed"],"Demon Slayer":["Grim Scythe","Demon Lash","Soul Eater","Dark Thrust","Chaos Lock","Vengeance","Judgment","Vortex of Doom","Raven Storm","Carrion Breath","Infernal Concussion","Demon Impact","Demon Cry","Dark Metamorphosis","Binding Darkness","Cerberus Chomp"],"Dual Blade":["Bandit Slash","Tornado Spin","Fatal Blow","Slash Storm","Flashbang","Blade Ascension","Flying Assaulter","Bloody Storm","Chains of Hell","Final Cut","Blade Fury","Phantom Blow","Sudden Raid","Asura's Anger","Blade Clone"],"Evan":["Mana Burst","Dragon Spark","Wind Circle","Dragon Flash","Thunder Circle","Dragon Dive","Magic Debris","Earth Circle","Dragon Breath","Dark Fog","Dragon Master","Summon Onyx Dragon"],"Fire Poison Mage":["Flame Orb","Poison Breath","Ignite","Explosion","Poison Mist","Teleport Mastery","Flame Haze","Mist Eruption","Ifrit","Flame Sweep","Meteor Shower","Inferno Aura","Megiddo Flame"],"Hayato":["Hitokiri Hundred Strike","Surging Blade","Vapor Blade","Sweeping Sword","Sanrenzan","Tornado Blade","Sudden Strike","Shinsoku","Hitokiri Strike","Falcon's Honor"],"Hero":["Final Attack","Brandish","Flash Blade","Intrepid Slash","Rush","Cry Valhalla","Beam Blade","Raging Blow","Puncture","Rising Rage"],"Hoyoung":["Humanity","Earth","Heaven","Evil-Sealing Gourd","Seeking Ghost Flame","Degeneration","Butterfly Dream","Star Vortex","Clone"],"Ice Lightning Mage":["Thunder Bolt","Cold Beam","Chilling Step","Ice Strike","Frost Ward","Thunder Sphere","Elquines","Chain Lightning","Blizzard","Frozen Orb","Lightning Orb"],"Illium":["Radiant Javelin II","Umbral Brand III","Reaction - Destruction II","Machina","Vortex Wings","Longinus Spear","Longinus Zone","Deus"],"Jett":["Starline One","Blaster Barrage","Starline Two","Stellar Impact","Vortex Cross","Falling Stars","Starline Three","Cosmic Upheaval","Starforce Salvo","Backup Beatdown","Planet Buster","Singularity Shock"],"Kain":["Strike Arrow","Scattering Shot","Dragon Fang","Shaft Break","Phantom Blade","Death's Blessing","Falling Dust","Chain Sickle"],"Kaiser":["Dragon Slash","Flame Surge","Impact Wave","Piercing Blaze","Tempest Blades","Wing Beat","Pressure Chain","Stone Dragon","Gigas Wave","Dragon Barrage","Blade Burst","Inferno Breath","Ancestral Prominence"],"Khali":["Arts Cross Cut","Arts Dual Edge","Void Rush","Arts Triple Bash","Resonate","Hex Chakram Sweep","Arts Flurry","Void Blitz","Death Blossom"],"Kanna":["Shikigami Haunting","Ghost Yaksha Boss","Kishin Shoukan","Nightghost Guide","Shikigami Charm","Exorcist's Charm","Tengu Strike","Yosuzume","Vanquisher's Charm","Orochi Unbound","Falling Sakura","Binding Tempest","Nine-Tailed Fury","Shikigami Doppelganger","Veritable Pandemonium"],"Kinesis":["Psychic Force","Kinetic Crash","Kinetic Piledriver","Ultimate - Deep Impact","Psychic Drain","Psychic Grab","Ultimate - Trainwreck","Kinetic Combo","Mind Quake","Ultimate - B.P.M.","Mental Tempest","Mental Shock","Ultimate - Metal Press"],"Lara":["Essence Sprinkle","Wakeup Call","Mountain Kid","Mountain Seeds","Dragon Vein Eruption","Dragon Vein Absorption","Vine Coil","Dragon Vein Traces"],"Luminous":["Flash Shower","Abyssal Drop","Sylvan Lance","Pressure Void","Spectral Light","Ray of Redemption","Moonlight Spear","Death Scythe","Reflection","Morning Star","Apocalypse","Ender","Armageddon"],"Lynn":["Strike","Peck","Sneak Attack","Earth Pulverization","Sweep","Predator's Blow"],"Marksman":["Arrow Blow","Final Attack","Covering Fire","Bolt Burst","Piercing Arrow","Snipe","High Speed Shot"],"Mechanic":["ME-07 Drillhands","Gatling Gun","Rocket Booster","Heavy Gatling Gun","Homing Beacon","Robo Launcher RM7","Punch Launcher","Rock 'n Shock","Heavy Salvo","Support Unit H-EX","Giant Robot SG-88","Bots 'n Tots","Heavy Salvo Plus","Distortion Bomb"],"Mercedes":["Swift Dual Shot","Rising Rush","Stunning Strikes","Leaf Tornado","Unicorn Spike","Elemental Knights","Ishtar's Ring","Spikes Royale","Lightning Edge","Wrath of Enil"],"Mihile":["Shining Pierce","Royal Guard","Radiant Driver","Four-Point Assault","Final Attack","Soul Release","Radiant Cross","Install Shield","Charging Light"],"Night Lord":["Shuriken Burst","Gust Charm","Assassin's Mark","Dark Flare","Triple Throw","Shuriken Challenge","Quad Star","Sudden Raid","Showdown","Death Star"],"Night Walker":["Lucky Seven","Shadow Bat","Triple Throw","Quad Star","Shadow Spark","Quintuple Star","Dark Omen","Shadow Stitch","Dominion"],"Paladin":["Final Attack","Divine Swing","Close Combat","Divine Judgment","Rush","Divine Charge","Blast","Heaven's Hammer","Smite Shield"],"Pathfinder":["Cardinal Deluge","Cardinal Burst","Cardinal Torrent","Shadow Raven","Swarm Shot","Triple Impact","Glyph of Impalement","Combo Assault","Ancient Astra"],"Phantom":["Double Entendre","Calling Card","Mille Cartes","Carte Noir","Blason Fantome","Rapier Wit","Mille Aiguilles","Penombre","Tempest","Rose Carte Finale","Impeccable Memory I","Impeccable Memory II","Impeccable Memory III","Impeccable Memory IV"],"Shade":["Flash Fist","Ground Pound","Blade Imp - Downward Slash","Blade Imp - Forward Slash","Fox Spirits","Shockwave Punch","Blade Imp - Spin Slash","Spirit Frenzy","Spirit Trap","Spirit Redemption","Bomb Punch","Spirit Claw","Death Mark","Soul Splitter","Spirit Incarnation"],"Shadower":["Savage Blow","Phase Dash","Meso Explosion","Midnight Carnival","Dark Flare","Assassinate","Cruel Stab","Sudden Raid","Shadow Veil"],"Thunder Breaker":["Lightning Punch","Flash","Shark Sweep","Tidal Crash","Ascension","Thunder","Gale","Annihilate","Thunderbolt","Deep Rising"],"Wild Hunter":["Double Shot","Summon Jaguar","Swipe","Final Attack","Dash 'n Slash","White Heat Rush","Enduring Fire","Hunting Assistant Unit","Sonic Roar","Wild Arrow Blast","Drill Salvo","Exploding Arrows"],"Wind Archer":["Breeze Arrow","Fairy Spiral","Gust Shot","Trifling Wind","Sentient Arrow","Pinpoint Pierce","Song of Heaven","Spiraling Vortex","Monsoon","Storm Bringer"],"Xenon":["Beam Spline","Pinpoint Salvo","Quicksilver","Ion Thrust","Combat Switch","Diagonal Chase","Gravity Pillar","Aegis System","Triangulation Boost","Beam Dance","Mecha Purge","Hypogram Field","Entangling Lash","Orbital Cataclysm"],"Zero":["Moon Strike","Piercing Thrust","Flash Assault","Blade Ring","Rolling Cross","Rolling Assault","Wind Cutter","Wind Striker","Storm Break","Shadow Rain"],"墨玄":["玄山 招式全開","神功 破碎拳","神功 旋風脚","神功 鐵山靠","神功 亂拳連激","神功 无影脚","密技 千斤錘","神功 大地崩裂","神功 移形換位","絕技 超熱波神力"]};
var logicNumber = 8;
var appVer = 10;
var skillCopy = 2;
var selectorChangeId = ["#skillOne", "#skillTwo", "#skillThree"];
var formTrio = ["SKILL1", "SKILL2", "SKILL3"];
var previewChangeId = ["#prev1", "#prev2", "#prev3"];
var selectedJob;
var nodestones = [];
var selectedSkills = [];
var cannotLead = [];
var nodeTally = {};
var nodeCollection = [];
var fullSkills = [];
var fractalA = [];
var fractalB =[];
var fractalC = [];
var rectangleA;
var rectangleB;
var rectangleC;
var templateSkill = document.createElement("img");
const flashHeader = document.getElementById('pickerTriPreview');
//templateSkill.src = "Images/MapleDivider.png";
templateSkill.src = "Images/templateB.png";
var maskSkill = document.createElement("img");
//maskSkill.src = "Images/mask.png";
maskSkill.src = "Images/maskB.png";
var fractalAMask = document.createElement("img");
var fractalBMask = document.createElement("img");
var fractalCMask = document.createElement("img");
/*fractalAMask.src = "Images/fractalATemplate.png";
fractalBMask.src = "Images/fractalBTemplate.png";
fractalCMask.src = "Images/fractalCTemplate.png";*/
fractalAMask.src = "Images/fatrim.png";
fractalBMask.src = "Images/fbtrim.png";
fractalCMask.src = "Images/fctrim.png";
var templateCV;
var maskVC;
var fractalAMaskCV;
var fractalBMaskCV;
var fractalCMaskCV;
var photoLoadCount = 0;
/**
 * Adds a new nodestone (created by the user)
 * Function for the new UI
 */
function addNodestone2() {
    var firstSkill = formTrio[0];
    var secondSkill = formTrio[1];
    var thirdSkill = formTrio[2];
    if ((formTrio[0] != formTrio[1]) && (formTrio[1] != formTrio[2]) && (formTrio[2] != formTrio[0])) {
        var currentNodestone = [firstSkill, secondSkill, thirdSkill];
        if (isAlreadyIn(nodestones, formTrio)) {
            alert("Node Combination Already Exists");
        }
        else if (firstSkill == "SKILL1" || secondSkill == "SKILL2" || thirdSkill == "SKILL3"){
            alert("You have not selected three skills yet.");
        }
        else {
            validFlash();
            nodestones.push(currentNodestone);
            newNode(formTrio);
        }

    }
    else {
        alert("A Skill Cannot Appear in a node more than once.");
    }
};

/**
 * Checks whether "item" is already inside "arr" (an array)
 */

function isAlreadyIn(arr, item) {
    var itemString = JSON.stringify(item);
    var contain = arr.some(function (ele) {
        return JSON.stringify(ele) === itemString;
    });
    return contain;
}

/**
 * Creates a new entry in the nodestone collection panel based on data from nodeSet(an array of size 3) 
 */
function newNode(nodeSet) {
    var tableRef = document.getElementById("nodeList").getElementsByTagName("tbody")[0];
    var newRow = tableRef.insertRow();
    var newCell = newRow.insertCell(0);
    newCell.setAttribute("name", "imageName");
    var newLiner = document.createElement("br");
    var newText = document.createTextNode(nodeSet[0] + "\n" + nodeSet[1] + "\n" + nodeSet[2]);
    newCell.appendChild(newText);
    var newCell = newRow.insertCell(1);
    newCell.setAttribute("name", "imageCell");
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/" + selectedJob + "/" + nodeSet[0] + ".png");
    newImg.setAttribute("name", "firstSlice");//trial
    newCell.appendChild(newImg);
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/" + selectedJob + "/" + nodeSet[1] + ".png");
    newImg.setAttribute("name", "secondSlice");
    newCell.appendChild(newImg);
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/" + selectedJob + "/" + nodeSet[2] + ".png");
    newImg.setAttribute("name", "thirdSlice");
    newCell.appendChild(newImg);
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/MapleDivider.png");
    newImg.setAttribute("name", "divider");
    newCell.appendChild(newImg);
    var newCell = newRow.insertCell(2);
    var newText = document.createTextNode("SCORE");
    newCell.appendChild(newText);
    var newCell = newRow.insertCell(3);
    var b = document.createElement('button');
    b.setAttribute("class", "btn btn-primary");
    b.textContent = 'Add';
    b.onclick = function () {
        if (!isAlreadyIn(nodeCollection, nodestones[$(this).closest('tr').attr("name")]) && !isAlreadyIn(cannotLead, nodestones[$(this).closest('tr').attr("name")][0])) {
            disableDeletion(true);
            $(this).closest('tr').removeClass("bg-danger bg-warning bg-success");
            $(this).closest('tr').addClass("bg-info");
            updateNodeScore(nodestones[$(this).closest('tr').attr("name")], "ADD");
            nodeCollection.push(nodestones[$(this).closest('tr').attr("name")]);
            cannotLead.push(nodestones[$(this).closest('tr').attr("name")][0]);
            computeNodeScoreAll();
            computeAuxData();
            copyToCollection($(this).closest('tr').attr("name"));
        }
        else {
            alert("The trio you are trying to add is either already in or the leading skill conflicts with items inside the list. \n If you are using the Auto-Build function, just press OK to continue the process.");
        }

        return false;
    };
    newCell.appendChild(b);
    var newCell = newRow.insertCell(4);
    var c = document.createElement('button');
    c.setAttribute("class", "btn btn-primary");
    c.setAttribute("name", "delete");
    c.textContent = 'Remove';
    c.onclick = function () {
        nodestones.splice($(this).closest('tr').attr("name"), 1);
        changeOrder($(this).closest('tr').attr("name"));
        $(this).closest('tr').remove();
        return false;
    };
    newCell.appendChild(c);
    $("#nodeList  tr:last").attr("name", ($("#nodeList tr").length) - 2);
    if ($("#nodeCombo tbody tr").length != 0) {
        disableDeletion(true);
    }
    computeNodeScoreAll();
}

/**
 * Originally was supposed to load all skill data from a JSON file.
 * Current use is to load all supported jobs in the "Select Job:" dropdown
 */
function loadJSON() {
    for (jobs in skillData) {
        var jobSelection = document.getElementById("jobSelect");
        jobSelection.innerHTML = jobSelection.innerHTML +
            '<option value="' + jobs + '">' + jobs + '</option>';
    }
    let nsmCookie = getCookie("nodeStoneShowModal");
    let nsvCookie = getCookie("nodeStoneVersion");
    //console.log(document.cookie);
    if(nsvCookie != appVer || nsmCookie != "false"){
        $("#whatsNewModal").modal();
    }
}

/**
 * Changes the list of skills a user can pick to rebuild their tri-nodes.
 * Also in charge of hiding certain div's based on selectedJob's value (should be moved to a separate function)
 */
function skillChange() {
    selectedJob = $("#jobSelect").val();
    initializeTally();
    selectorChange();
    clearLeftoverData();
    if (selectedJob.length > 0) {
        $("#normalOperation").attr("name", "noOp");
        $("#helpOperation").attr("name", "hiddenObj");
        //$("#optionOperation").attr("name", "hiddenObj");
        $("#nodePhotoLoader").attr("name", "noOp");
    }
    else {
        $("#normalOperation").attr("name", "hiddenObj");
        $("#helpOperation").attr("name", "noOp");
        //$("#optionOperation").attr("name", "hiddenObj");
        $("#nodePhotoLoader").attr("name", "hiddenObj");
    }
    if(typeof skillData[selectedJob] !== "undefined"){
        loadFractals();
    }
    removePhotoResiduals();
}

/**
 * Changes the Skill icon preview in build nodestone
 */
function previewChange(changedPart) {

    $(previewChangeId[changedPart - 1]).attr("src", "Images/" + selectedJob + "/" + $(selectorChangeId[changedPart - 1]).val() + ".png");
}

/**
 * Changes the amount of copies a skill should have 
 */
function numberChange() {
    skillCopy = parseInt($("#copyNumber").val());
    formulateTrios(-1, true);
}

/**
 * Changes the selectable skills in the first div which users pick to select which skills they would like their perfect trios to have
 */
function selectorChange() {
    var tableNode = document.getElementById("skillOption1");
    tableNode.innerHTML = "";
    nodestones = [];
    selectedSkills = [];
    cannotLead = [];
    nodeCollection = [];
    document.getElementById("nodeList").getElementsByTagName("tbody")[0].innerHTML = "";
    document.getElementById("nodeCombo").getElementsByTagName("tbody")[0].innerHTML = "";
    selectedJob = $("#jobSelect").val();
    updateNodeScore(["A", "B", "C"], "Nothing");
    if (selectedJob.length > 0) {
        var tableRef = document.getElementById("skillOption1");
        for (i = 0; i < skillData[selectedJob].length; i++) {
            if (i % 5 == 0) {
                var newRow = tableRef.insertRow();
            }
            var newCell = newRow.insertCell(i % 5);
            var newImg = document.createElement("img");
            newImg.setAttribute("src", "Images/" + selectedJob + "/" + skillData[selectedJob][i] + ".png");
            newCell.appendChild(newImg);
            var newText = document.createTextNode(" " + skillData[selectedJob][i]);
            newCell.appendChild(newText);
            newCell.setAttribute("name", skillData[selectedJob][i]);
            newCell.setAttribute("onclick", 'formulateTrios("' + skillData[selectedJob][i] + '")');
        }
    }
    selectorChangeTri();
}

/**
 * Changes the selectable skills in the first div which users pick to select which skills they would like their perfect trios to have
 */
function selectorChangeTri() {
    var tableNode = document.getElementById("skillOption1p5");
    tableNode.innerHTML = "";
    selectedJob = $("#jobSelect").val();
    if (selectedJob.length > 0) {
        $('#prev1a').attr("src", "Images/MapleDivider.png");
        $('#prev2a').attr("src", "Images/MapleDivider.png");
        $('#prev3a').attr("src", "Images/MapleDivider.png");
        $('#textSel1').text("");
        $('#textSel2').text("");
        $('#textSel3').text("");
        var tableRef = document.getElementById("skillOption1p5");
        for (var i = 0; i < skillData[selectedJob].length; i++) {
            if (i % 5 == 0) {
                var newRow = tableRef.insertRow();
            }
            var newCell = newRow.insertCell(-1);
            var newImg = document.createElement("img");
            newImg.setAttribute("src", "Images/" + selectedJob + "/" + skillData[selectedJob][i] + ".png");
            newCell.appendChild(newImg);
            newCell.setAttribute("name", skillData[selectedJob][i]);
            for (var j = 0; j < 3; j++) {
                var newText = document.createTextNode("");
                var newCell = newRow.insertCell(-1);
                newCell.appendChild(newText);
                newCell.setAttribute("name", skillData[selectedJob][i] + "_slot_" + (j + 1));
                newCell.setAttribute("class", "slot_" + (j + 1));
                newCell.setAttribute("onclick", 'selectSegment("' + skillData[selectedJob][i] + '",' + j + ')');
            }
        }
    }
}

/**
 * 
 * New Logic for creation of Trios 
 */
function selectSegment(skillName, segment) {
    formTrio[segment] = skillName;
    $('td.slot_' + (segment + 1) + '[name="' + skillName + '_slot_' + (segment + 1) + '"]').addClass("bg-primary");
    $('td.slot_' + (segment + 1) + ':not(td[name="' + skillName + '_slot_' + (segment + 1) + '"])').removeClass("bg-primary");
    $('#prev' + (segment + 1) + 'a').attr("src", "Images/" + selectedJob + "/" + skillName + ".png");
    $('#textSel' + (segment + 1)).text(skillName);

}

/**
 * UI Logic for the 1st div.
 * Also in charge of computing for a node statistic (Best Outcome)
 */
function formulateTrios(selectedOption, skillCopyChange=false) {
    var nodeSlotData = 0;
    if(!skillCopyChange){
        if (isAlreadyIn(selectedSkills, selectedOption)) {
            selectedSkills = selectedSkills.filter(function (value, index, arr) {
                return value != selectedOption;
            });
            $("#skillOption1 td[name=\"" + selectedOption + "\"]").removeClass("bg-primary");
        }
        else {
            selectedSkills.push(selectedOption);
            $("#skillOption1 td[name=\"" + selectedOption + "\"").addClass("bg-primary");
        }
    }
    var selectedFormulation = selectedSkills.length;
    nodeSlotData = 3 - (selectedFormulation * skillCopy % 3);
    if (nodeSlotData == 3) {
        nodeSlotData = 0;
    }
    var nodePositive = (Math.ceil(selectedFormulation * skillCopy / 3) * 3) - nodeSlotData;
    document.getElementsByName("skillCounter")[0].innerHTML = selectedSkills.length;
    if (selectedFormulation == 1) {
        document.getElementsByName("bestOutcome")[0].innerHTML = skillCopy + "(" + skillCopy + " slots for selected and " + skillCopy * 2 + " slots for any skill)";
    }
    else {
        document.getElementsByName("bestOutcome")[0].innerHTML = Math.ceil(selectedFormulation * skillCopy / 3) + "(" + nodePositive + " slots for selected and " + nodeSlotData + " slot(s) for any skill)";
    }
    initializeTally();
    computeNodeScore();
    updateNodeScore(["A", "B", "C"], "Nothing");
    computeAuxData();
    computeNodeScoreAll();

}

/**
 * Changes the name (ID #) of every node affected when a node is deleted.
 * Ex. removing node ID # 34 would result in 34 being empty. Nodes with ID 35 onwards would shift down to ensure ID 34 is used
 * This is the reason why deleting nodes is not allowed while ANY tri-node is equipped 
 */
function changeOrder(deletedNode) {
    $('#nodeList > tbody  > tr').each(
        function (index) {
            if ($(this).attr("name") > deletedNode) {
                $(this).attr("name", $(this).attr("name") - 1);
            }
        }
    )
    $('#nodeCombo > tbody  > tr').each(
        function (index) {
            if ($(this).attr("name") > deletedNode) {
                $(this).attr("name", $(this).attr("name") - 1);
            }
        }
    )
}

/**
 * Initializes the tally/count if a skill is already present in the equipped tri-node twice/thrice (based on skillCopy).
 * A count of 2 means that said skill can still be equipped 2 more time, etc.
 */
function initializeTally() {
    selectedJob = $("#jobSelect").val();
    nodeTally = [];
    if (selectedJob.length > 0) {
        for (i = 0; i < skillData[selectedJob].length; i++) {
            if (isAlreadyIn(selectedSkills, skillData[selectedJob][i])) {
                nodeTally[skillData[selectedJob][i]] = skillCopy;
            }
            else {
                nodeTally[skillData[selectedJob][i]] = 0;
            }
        }

    }
}

/**
 * Copies the selected node to equip to the Equipped nodes list (inside div 3)
 */
function copyToCollection(selectName) {
    var tableRef = document.getElementById("nodeCombo").getElementsByTagName("tbody")[0];
    var newRow = tableRef.insertRow();
    var newCell = newRow.insertCell(0);
    newCell.setAttribute("name", "imageName");
    var newLiner = document.createElement("br");
    var newText = document.createTextNode(nodestones[selectName][0] + "\n" + nodestones[selectName][1] + "\n" + nodestones[selectName][2]);
    newCell.appendChild(newText);
    var newCell = newRow.insertCell(1);
    newCell.setAttribute("name", "imageCell");
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/" + selectedJob + "/" + nodestones[selectName][0] + ".png");
    newImg.setAttribute("name", "firstSlice");
    newCell.appendChild(newImg);
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/" + selectedJob + "/" + nodestones[selectName][1] + ".png");
    newImg.setAttribute("name", "secondSlice");
    newCell.appendChild(newImg);
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/" + selectedJob + "/" + nodestones[selectName][2] + ".png");
    newImg.setAttribute("name", "thirdSlice");
    newCell.appendChild(newImg);
    var newImg = document.createElement("img");
    newImg.setAttribute("src", "Images/MapleDivider.png");
    newImg.setAttribute("name", "divider");
    newCell.appendChild(newImg);
    var newCell = newRow.insertCell(2);
    var b = document.createElement('button');
    b.setAttribute("class", "btn btn-primary");
    b.textContent = 'Unequip';
    b.onclick = function () {
        $('#nodeList > tbody  > tr[name="' + selectName + '"]').removeClass("bg-info");
        nodeCollection.splice(($(this).closest('td').parent()[0].sectionRowIndex), 1);
        cannotLead.splice(($(this).closest('td').parent()[0].sectionRowIndex), 1);
        updateNodeScore(nodestones[$(this).closest('tr').attr("name")], "REMOVE");
        computeNodeScoreAll();
        $(this).closest('tr').remove();
        disableDeletion(false);
        computeAuxData();
        return false;
    };
    newCell.appendChild(b);
    $("#nodeCombo  tr:last").attr("name", selectName);
}

/**
 * Enables or disables deletion in nodestone list
 */
function disableDeletion(statusLock) {
    if (statusLock == true) {
        $("#nodeList").find("button[name='delete']").attr("disabled", true);
    }
    else if ($("#nodeCombo tbody tr").length == 0) {
        $("#nodeList").find("button[name='delete']").attr("disabled", false);
        $("#autoBuild").attr("disabled", false);
    }
}

/**
 * Deducts 1 to every skill currently equipped in the tally.
 */
function computeNodeScore() {
    for (i = 0; i < nodeCollection.length; i++) {
        nodeTally[nodeCollection[i][0]] = nodeTally[nodeCollection[i][0]] - 1;
        nodeTally[nodeCollection[i][1]] = nodeTally[nodeCollection[i][1]] - 1;
        nodeTally[nodeCollection[i][2]] = nodeTally[nodeCollection[i][2]] - 1;
    }
}

/**
 * Computes the nodescore for a given trio
 * Single Nodestone version of the function below
 */
function computeNodeScoreSingle(singleNode){
    var nSOne = singleNode[0];
    var nSTwo = singleNode[1];
    var nSThree = singleNode[2];
    var nSScore = 0;
    if (isAlreadyIn(cannotLead, nSOne)) {
        nSScore = -1;
    }
    else {
        if (isAlreadyIn(selectedSkills, nSOne)) {
            nSScore++;
            if (nodeTally[nSOne] > 0) {
                nSScore++;
            }
        }
        if (isAlreadyIn(selectedSkills, nSTwo)) {
            nSScore++;
            if (nodeTally[nSTwo] > 0) {
                nSScore++;
            }
        }
        if (isAlreadyIn(selectedSkills, nSThree)) {
            nSScore++;
            if (nodeTally[nSThree] > 0) {
                nSScore++;
            }
        }
    }
    return nSScore;
}

/**
 * Recomputes the nodescore for every skill inside the nodelist (div 2)
 * Fires off everytime a node is equipped, unequipped, or a skill is added or removed from the desired skills list
 */
function computeNodeScoreAll() {
    $('#nodeList > tbody  > tr').each(
        function (index) {
            if (!$(this).hasClass("bg-info")) {
                $(this).removeClass("bg-danger bg-warning bg-success");
            }
            var nOne = nodestones[$(this).attr("name")][0];
            var nTwo = nodestones[$(this).attr("name")][1];
            var nThree = nodestones[$(this).attr("name")][2];
            var nScore = 0;
            if (isAlreadyIn(cannotLead, nOne)) {
                nScore = -1;
            }
            else {
                if (isAlreadyIn(selectedSkills, nOne)) {
                    nScore++;
                    if (nodeTally[nOne] > 0) {
                        nScore++;
                    }
                }
                if (isAlreadyIn(selectedSkills, nTwo)) {
                    nScore++;
                    if (nodeTally[nTwo] > 0) {
                        nScore++;
                    }
                }
                if (isAlreadyIn(selectedSkills, nThree)) {
                    nScore++;
                    if (nodeTally[nThree] > 0) {
                        nScore++;
                    }
                }

            }
            $("td:nth-last-child(3)", this).text(nScore);
            if (nScore == 0 && !$(this).hasClass("bg-info")) {
                $(this).addClass("bg-danger");
            }
            else if (nScore < 6 && !$(this).hasClass("bg-info") && nScore > 0) {
                $(this).addClass("bg-warning");
            }
            else if (nScore > 5 && !$(this).hasClass("bg-info")) {
                $(this).addClass("bg-success");
            }
            else if (nScore < 1 && !$(this).hasClass("bg-info")) {
                $(this).addClass("bg-danger");
                $("td:nth-last-child(3)", this).text("-1 (Leading Skill)");
            }
            else if (nScore < 0 && $(this).hasClass("bg-info")) {
                $("td:nth-last-child(3)", this).text("-1 (In Use)");
            }
        }
    )

}

/**
 * Updates nodescores in tally based on if a node is equipped or unequipped.
 * Also is responsible for updating the lower right table in div 3 which is responsible for keeping track of how many times a skill appears in the equipped nodes (might want to move this function)
 */
function updateNodeScore(subtractNode, conditions) {
    if (conditions == "ADD") {
        nodeTally[subtractNode[0]] = nodeTally[subtractNode[0]] - 1;
        nodeTally[subtractNode[1]] = nodeTally[subtractNode[1]] - 1;
        nodeTally[subtractNode[2]] = nodeTally[subtractNode[2]] - 1;
    }
    else if (conditions == "REMOVE") {
        nodeTally[subtractNode[0]] = nodeTally[subtractNode[0]] + 1;
        nodeTally[subtractNode[1]] = nodeTally[subtractNode[1]] + 1;
        nodeTally[subtractNode[2]] = nodeTally[subtractNode[2]] + 1;
    }
    var tableRef = document.getElementById("nodeStatistics2").getElementsByTagName("tbody")[0];
    tableRef.innerHTML = "";
    if (selectedJob.length > 0) {
        for (k = 0; k < skillData[selectedJob].length; k++) {
            var newRow = tableRef.insertRow();
            var newCell = newRow.insertCell(0);
            var newImg = document.createElement("img");
            newImg.setAttribute("src", "Images/" + selectedJob + "/" + skillData[selectedJob][k] + ".png");
            newCell.appendChild(newImg);
            var newText = document.createTextNode(" " + skillData[selectedJob][k]);
            newCell.appendChild(newText);
            var newCell = newRow.insertCell(1);
            if (isAlreadyIn(selectedSkills, skillData[selectedJob][k])) {
                var newText = document.createTextNode("YES");
                newCell.appendChild(newText);
                var newCell = newRow.insertCell(2);
                var newText = document.createTextNode(skillCopy - nodeTally[skillData[selectedJob][k]]);
                if (skillCopy - nodeTally[skillData[selectedJob][k]] == skillCopy) {
                    newRow.classList.add("bg-success");
                }
                else if (skillCopy - nodeTally[skillData[selectedJob][k]] < skillCopy && skillCopy - nodeTally[skillData[selectedJob][k]] > 0) {
                    newRow.classList.add("bg-warning");
                }
                else {
                    newRow.classList.add("bg-danger");
                }
            }
            else {
                var newText = document.createTextNode("NO");
                newCell.appendChild(newText);
                var newCell = newRow.insertCell(2);
                var newText = document.createTextNode(-nodeTally[skillData[selectedJob][k]]);
                newRow.classList.add("bg-info");
            }
            newCell.appendChild(newText);
        }
    }
}

/**
 * Computes other data in the Nodestatistics tab (# of nodes used, efficiency)
 */
function computeAuxData() {
    document.getElementsByName("nodeUsage")[0].innerHTML = nodeCollection.length;
    var tally = 0;
    for (j = 0; j < selectedSkills.length; j++) {
        var nodeTaken = 0;
        nodeTaken = skillCopy - nodeTally[selectedSkills[j]];
        if (nodeTaken < skillCopy) {
            tally = tally + nodeTaken;
        }
        else {
            tally = tally + skillCopy;
        }
        //console.log("Tally is at: " + tally + " last node taken was: " + nodeTaken);
    }
    let efficiencyNumber = Math.round((tally / (nodeCollection.length * 3) * 100 + Number.EPSILON) * 100) / 100;
    if(!isNaN(efficiencyNumber)){
        document.getElementsByName("nodeEfficiency")[0].innerHTML = tally + "/" + (nodeCollection.length) * 3 + "(" + Math.round((tally / (nodeCollection.length * 3) * 100 + Number.EPSILON) * 100) / 100 + "% Efficiency)";
    }
    else{
        document.getElementsByName("nodeEfficiency")[0].innerHTML = tally + "/" + (nodeCollection.length) * 3;
    }
}

/**
 * Clears skill appearance tracker and best outcome if job is suddenly switched
 */
function clearLeftoverData() {
    document.getElementsByName("skillCounter")[0].innerHTML = selectedSkills.length;
    document.getElementsByName("bestOutcome")[0].innerHTML = "0(0 slots for selected and 0 slots for any skill)";
    computeAuxData();

}

/**
 * Sort function for headers
 */
$('table[name="sortable"] th').click(function () {
    var table = $(this).parents('table').eq(0)
    var rows = table.find('tr:gt(0)').toArray().sort(comparer($(this).index()))
    this.asc = !this.asc
    if (!this.asc) { rows = rows.reverse() }
    for (var i = 0; i < rows.length; i++) { table.append(rows[i]) }
})
function comparer(index) {
    return function (a, b) {
        var valA = getCellValue(a, index), valB = getCellValue(b, index)
        return $.isNumeric(valA) && $.isNumeric(valB) ? valA - valB : valA.toString().localeCompare(valB)
    }
}
function getCellValue(row, index) { return $(row).children('td').eq(index).text() }

/**
 * Some minor Web responsive additions
 */
$(window).on('resize load', function () {
    if ($(window).width() < 1000) {
        $("#leftCreator").addClass('col-12').removeClass('col-5');
        $("#rightCreator").addClass('col-12').removeClass('col-7');
        $("#leftCombo").addClass('col-12').removeClass('col-6');
        $("#rightCombo").addClass('col-12').removeClass('col-6');
    }
    else {
        $("#leftCreator").addClass('col-5').removeClass('col-12');
        $("#rightCreator").addClass('col-7').removeClass('col-12');
        $("#leftCombo").addClass('col-6').removeClass('col-12');
        $("#rightCombo").addClass('col-6').removeClass('col-12');
    }
});

/**
 * Allows sections of the page to collapse
 */
function divcollapse(sectionToCollapse) {
    $("#" + sectionToCollapse + "").collapse("toggle");
    $("#" + sectionToCollapse + "Arrow").toggleClass("bi bi-caret-down-square-fill");
    $("#" + sectionToCollapse + "Arrow").toggleClass("bi bi-caret-up-square-fill");
}

/**
 * Generates the save string
 */
function genList() {
    var generated;
    generated = logicNumber + "|" + $("#jobSelect").val() + "|";
    for (i = 0; i < nodestones.length; i++) {
        generated = generated + skillData[selectedJob].indexOf(nodestones[i][0]) + "," + skillData[selectedJob].indexOf(nodestones[i][1]) + "," + skillData[selectedJob].indexOf(nodestones[i][2]) + "|";
    }
    generated = generated.slice(0, -1);
    $("#saveLoadArea").val(generated);
}

/**
 * Loads the pasted save string
 * TODO: Check validity
 */
function loadList() {
    var listLoader = $("#saveLoadArea").val();
    listLoader = listLoader.split("|");
    if (listLoader[0] == logicNumber) {
        $("#jobSelect").val(listLoader[1]);
        selectedJob = listLoader[1];
        $("#normalOperation").attr('name', 'noOp');
        $("#helpOperation").attr('name', 'hiddenObj');
        //$("#optionOperation").attr('name', 'hiddenObj');
        $("#nodePhotoLoader").attr('name', 'noOp');
        initializeTally();
        selectorChange();
        clearLeftoverData();
        //loadFractals();
        //removePhotoResiduals();
        for (i = 2; i < listLoader.length; i++) {
            var temp = listLoader[i].split(",");
            temp[0] = skillData[selectedJob][temp[0]];
            temp[1] = skillData[selectedJob][temp[1]];
            temp[2] = skillData[selectedJob][temp[2]];
            nodestones.push(temp);
            newNode(temp);
        }
    }
    else {
        alert("Your save file is from another version of the Builder. If you think your job was not updated in subsequent revisions, change the first digit in your savefile to " + logicNumber + " and try loading again.");
    }
}

/**
 * Debug function just to check values of variables
 */
function checkVar() {
    console.log("formTrio");
    console.log(formTrio);
    console.log("nodestones");
    console.log(nodestones);
    console.log("selectedSkills");
    console.log(selectedSkills);
    console.log("cannotLead");
    console.log(cannotLead);
    console.log("nodeTally");
    console.log(nodeTally);
    console.log("nodeCollection");
    console.log(nodeCollection);
}



/**
 * Auto Build Function via Webworker
 */
function buildPerfectTri() {
    var set = nodestones.slice();
    set = setReduction(set);
    var builder = new Worker('builder.js');
    var comboMessage = selectedJob + "||| " + JSON.stringify(set) + "||| " + JSON.stringify(nodeCollection) + "||| " + JSON.stringify(selectedSkills) + "||| " + skillCopy;
    builder.postMessage(comboMessage);
    builder.onmessage = function (e) {
        /*var set = nodestones.slice();
        for (var i = 0; i < nodeCollection.length; i++) {
            set = set.filter(function (e) { return e !== nodeCollection[i] });
        }
        var k = Math.ceil(selectedSkills.length * skillCopy / 3);
        var results = [];
        bigSetHolder = [];
        setholder = [];
        setholder = nodeCollection.slice();
        results = JSON.parse(e.data);
        if (setholder.length > k) {
            alert("You are currently equipped with more nodestones than the optimal.");
        }*/
        results = JSON.parse(e.data);
        //else if (results[0] != "NONE FOUND") {
        if (results[0] != "NONE FOUND") {
            autoButtonClick2(results[0]);
        }
        else {
            alert("No Optimal Nodestone Combination Found.");
        }
        builder.terminate();
    }

}

/**
 * Generate a Smaller Node Set (Only contains trios with scores 4-6)
 */
function setReduction(setItem){
    var setX = setItem
    for (var i = 0; i < nodeCollection.length; i++) {
        setX = setX.filter(function (e) { return e !== nodeCollection[i] });
    }
    if(selectedSkills.length%3 == 0){
        setX = setX.filter(function (e) { return computeNodeScoreSingle(e) == 6});
    }
    else{
        setX = setX.filter(function (e) { return computeNodeScoreSingle(e) >= 4});
    }
    return setX;
}

/**
 * Auto Build Function[Starts Here](Do not expect this to work)
 */
var setholder = [];
var bigSetHolder = [];

function printCombination() {
    var set = nodestones.slice();
    set = setReduction(set);
    //console.log(set.length);
    var k = Math.ceil(selectedSkills.length * skillCopy / 3);
    var results = [];
    bigSetHolder = [];
    setholder = [];
    setholder = nodeCollection.slice();
    if (setholder.length < k) {
        results = comboMaker(1 + setholder.length, 1 + setholder.length, k, set, -1);

    }
    if (results.length > 0) {
        autoButtonClick(results[0]);
    }
    else if (setholder.length > k) {
        alert("You are currently equipped with more nodestones than the optimal.");
    }
    else {
        alert("No Optimal Nodestone Combination Found.");
    }
}

function comboMaker(currLev, startLev, maxLev, nodePool, basis) {
    for (var i = basis + 1; i < nodePool.length - maxLev + currLev; i++) {
        setholder.push(nodePool[i]);
        if(legalLeading(nodePool[i])){
            if (currLev == maxLev) {
                var baseScore = constructScore();
                if (legalLeading(setholder) && legalScoring(setholder, baseScore)) {
                    bigSetHolder.push(setholder.slice());
                    return bigSetHolder;
                }
            }
            else if (bigSetHolder.length > 0) {
                //console.log(bigSetHolder);
                return bigSetHolder;
            }
            else {
                comboMaker(currLev + 1, startLev, maxLev, nodePool, i);
            }
        }
        setholder.pop();
    }
    if (currLev == startLev) {
        return bigSetHolder;
    }
}

/**
 * 
 * Checks if all the Leading Skill of a nodestone set does not repeat itself
 * 
 */
function legalLeading(data) {
    var leads = [];
    var flag = 0;
    for (var i = 0; i < data.length; i++) {
        if (isAlreadyIn(leads, data[i][0])) {
            flag = 1;
            break;
        }
        else {
            leads.push(data[i][0]);
        }
    }
    if (flag == 0) {
        return true;
    }
    return false;
};

/**
 * 
 * Constructs the basis or comparison to compare whether a nodeset is optimal.
 * 
 */
function constructScore() {
    var scoringCard = {};
    for (var i = 0; i < skillData[selectedJob].length; i++) {
        if (isAlreadyIn(selectedSkills, skillData[selectedJob][i])) {
            scoringCard[skillData[selectedJob][i]] = -skillCopy;
        }
        else {
            scoringCard[skillData[selectedJob][i]] = 0;
        }
    }
    return scoringCard;
};

/**
 * 
 * Compares a nodeset to the basis
 * 
 */
function legalScoring(testNodeSet, scoringSystem) {
    var currScoreBreak = Object.assign({}, scoringSystem);
    var currPotential = 0;
    for (var j = 0; j < testNodeSet.length; j++) {
        for (var k = 0; k < 3; k++) {
            currScoreBreak[testNodeSet[j][k]]++;
        }
    }
    for (const skillP in currScoreBreak) {
        if (currScoreBreak[skillP] < 0) {
            currPotential = -1;
        }
    }
    if (currPotential == 0) {
        return true;
    }
    return false;
};

function autoButtonClick(nodeToPick){
    for(var f = 0; f < nodeToPick.length; f++){
        var pressThisButton = nodestones.indexOf(nodeToPick[f]);
        $("#nodeList tr[name='"+pressThisButton+"'] td:nth-child(4)").find('button').click();
    }
    alert("Nodestone Combination Found! The Nodes have been equipped for you.");
};

function autoButtonClick2(nodeToPick) {
    for (var f = 0; f < nodeToPick.length; f++) {
        var pressThisButton = indexInArray(nodeToPick[f], nodestones);
        $("#nodeList tr[name='" + pressThisButton + "'] td:nth-child(4)").find('button').click();
    }
    alert("Nodestone Combination Found! The Nodes have been equipped for you.");
};

function autoButtonClick3() {
        $("#nodeCombo td:nth-child(3)").find('button').click();
};

function indexInArray(selection, baseBoard){
    var selStr = JSON.stringify(selection);
    selStr = selStr.replace(/"\[/g,"[");
    selStr = selStr.replace(/\]"/g,"]");
    selStr = selStr.replace(/\"/g,'"');
    //console.log(selStr);
    for (var g = 0; g < baseBoard.length; g++){
        if (selStr == JSON.stringify(baseBoard[g])){
            return g;
        }
    }
    return -1;
}

$(document).ready(function(e) {

    $("#photoLoadContainer").bind("paste", function(e){
 
        var items = (e.clipboardData || e.originalEvent.clipboardData).items;
      //  console.log(JSON.stringify(items)); // will give you the mime types
 
        for (index in items) 
        {
           var item = items[index];
           if (item.kind === 'file') 
           {
              var blob = item.getAsFile();
              var reader = new FileReader();
 
              reader.onload = function(event){
 
                  // show image in string 
                 // console.log(event.target.result);
 
                  // make a clone in textareaid2 
                  $("#uploadedPhotos").append("<img src='" + event.target.result + "' onClick='this.remove()'>");
              }; // data url!
              reader.readAsDataURL(blob);
           } 
           else
          {
             return true;
          }
       }
    });   // end bind
 });  // end ready

 function preLoad(){
    rectangleA = new cv.Rect(0,0,16,32);
    rectangleB = new cv.Rect(0,0,32,16);
    rectangleC = new cv.Rect(16,0,16,32);
    templateCV = cv.imread(templateSkill);
    maskCV = cv.imread(maskSkill);
    fractalAMaskCV = cv.imread(fractalAMask);
    fractalBMaskCV = cv.imread(fractalBMask);
    fractalCMaskCV = cv.imread(fractalCMask);
 }



 function loadFractals(){
	for(var skillFrac = 0; skillFrac < skillData[selectedJob].length; skillFrac++){
		var fullImage;
		//var img4 = new Image();
		//img4.crossOrigin = "Anonymous";
		
		//Test Promise
		const loadImage = (url) => new Promise((resolve, reject) => {
		const imgFull = new Image();
		  imgFull.addEventListener('load', () => resolve(imgFull));
		  imgFull.addEventListener('error', (err) => reject(err));
          imgFull.crossOrigin = "anonymous";
		  imgFull.src = url;
		  imgFull.setAttribute("title", skillFrac);
		});

		loadImage("Images/"+selectedJob+"/"+skillData[selectedJob][skillFrac]+".png")
		  .then(imgFull => {
			fullImage = cv.imread(imgFull);
			
			//let cutPhoto = new cv.Mat();
			//skillPuto.push(putoPao);
			//skillPuto[img4.name] = putoPao;
			//skillListB.push(img4.src.split("/").pop().split(".")[0].replace("%20"," "));
			//console.log(imgFull.title + "-" + skillData[selectedJob][imgFull.title]);
            fullSkills[imgFull.title] = fullImage;
			let cutPhotoA = fullImage.roi(rectangleA);
			//skillPuto1.push(cutPhoto);
			fractalA[imgFull.title] = cutPhotoA;
			let cutPhotoB = fullImage.roi(rectangleB);
			//skillPuto2.push(cutPhoto2);
			fractalB[imgFull.title] = cutPhotoB;
			let cutPhotoC = fullImage.roi(rectangleC);
			//skillPuto3.push(cutPhoto3);
			fractalC[imgFull.title] = cutPhotoC;
			
			/*var dcan = document.createElement("canvas");
			cv.imshow(dcan, putoPao);
			document.body.appendChild(dcan);*/
			//let paoImage = 
				})
		  .catch(err => console.error(err));
		
		//console.log("PUTO!");
		
		
		//null
	}
}

function readPhotos(){
    photoLoadCount = 0;
    var uploadedChildren = document.getElementById('uploadedPhotos').children;
    for (var chd = 0; chd < uploadedChildren.length; chd++) {
        try{
            var curPhoto = cv.imread(uploadedChildren[chd]);
            let dst = new cv.Mat();
            cv.matchTemplate(curPhoto, templateCV, dst, cv.TM_CCORR, maskCV);
            cv.normalize(dst, dst, 0, 1, cv.NORM_MINMAX, -1, new cv.Mat() );

            let color = new cv.Scalar(255, 0, 0, 255);

            var newDst = [];
            var start = 0;
            var end = dst.cols;

            for (var i = 0; i < dst.rows; i++) {

                newDst[i] = [];
                for (var k = 0; k < dst.cols; k++) {

                    newDst[i][k] = dst.data32F[start];
                    /*if(newDst[i][k] > 0.89){
                    console.log(newDst[i][k]);}*/

                    if (newDst[i][k] >0.89) {

                      //  let maxPoint = {
                      //      "x": k-1,
                      //      "y": i
                      //  }
                      //  let point = new cv.Point(k + templateCV.cols-1, i + templateCV.rows);
                      //  cv.rectangle(src, maxPoint, point, color, 1, cv.LINE_8, 0);
                        let photo = new cv.Mat();
                        let rectangleF = new cv.Rect(k,i,32,32);
                        photo = curPhoto.roi(rectangleF);
        
                        /*var skillA = findMatch(0, photo);
                        var skillB = findMatch(1, photo);
                        var skillC = findMatch(2, photo);*/
                        var skillA = findMatch2(0, photo, fractalAMaskCV);
                        var skillB = findMatch2(1, photo, fractalBMaskCV);
                        var skillC = findMatch2(2, photo, fractalCMaskCV);
                        //var stringing = skillData[selectedJob][skillA] + "\n" + skillData[selectedJob][skillB] + "\n" + skillData[selectedJob][skillC];
                        //alert(stringing);
                        addNodestonePhoto(skillA, skillB, skillC);
                    }
                    start++;
                }
                start = end;
                end = end + dst.cols;
            }
        }
        catch(e){
            //console.log("WOOPS XD");
            console.log("E("+ e.stack+"):"+ e);
        }
        if (photolLoadCount != 0){        
            alert("Currently, a total of " + photoLoadCount + " New Nodestones have been added");
        }
        else{
            alert("No New Nodestones have been added. If you think there should be at least 1, try refreshing the webpage.")
        }
    }
}

function findMatch(fractalCut, fractalSource){
    let photo2 = new cv.Mat();
    let maxNum = 0;
    let maxLoc = 0;
    let resMat = new cv.Mat();
    if(fractalCut == 0){
        photo2 = fractalSource.roi(rectangleA);
        for(var choice = 0; choice < skillData[selectedJob].length; choice++){
            cv.matchTemplate(photo2, fractalA[choice], resMat, cv.TM_CCORR_NORMED, new cv.Mat());
            if(cv.minMaxLoc(resMat).maxVal > maxNum){
                maxNum = cv.minMaxLoc(resMat).maxVal;
                maxLoc = choice;
            }
        }
        return maxLoc;
    }
    else if(fractalCut == 1){
        photo2 = fractalSource.roi(rectangleB);
        for(var choice = 0; choice < skillData[selectedJob].length; choice++){
            cv.matchTemplate(photo2, fractalB[choice], resMat, cv.TM_CCORR_NORMED, new cv.Mat());
            if(cv.minMaxLoc(resMat).maxVal > maxNum){
                maxNum = cv.minMaxLoc(resMat).maxVal;
                maxLoc = choice;
            }
        }
        return maxLoc;
    }
    else if(fractalCut == 2){
        photo2 = fractalSource.roi(rectangleC);
        for(var choice = 0; choice < skillData[selectedJob].length; choice++){
            cv.matchTemplate(photo2, fractalC[choice], resMat, cv.TM_CCORR_NORMED, new cv.Mat());
            if(cv.minMaxLoc(resMat).maxVal > maxNum){
                maxNum = cv.minMaxLoc(resMat).maxVal;
                maxLoc = choice;
            }
        }
        return maxLoc;
    }
    else{
        return 0;
    }
}

function findMatch2(fractalCut, fractalSource, fractalMask){
    //let photo2 = new cv.Mat();
    let maxNum = 0;
    let maxLoc = 0;
    let resMat = new cv.Mat();
    for(var choice = 0; choice < skillData[selectedJob].length; choice++){
        cv.matchTemplate(fractalSource, fullSkills[choice], resMat, cv.TM_CCORR_NORMED, fractalMask);
        //console.log(choice + "--"+cv.minMaxLoc(resMat).maxVal);
        if(cv.minMaxLoc(resMat).maxVal > maxNum){
            maxNum = cv.minMaxLoc(resMat).maxVal;
            maxLoc = choice;
        }
    }
    return maxLoc;
}

function addNodestonePhoto(fa, fb, fc) {
    var firstSkillP = skillData[selectedJob][fa];
    var secondSkillP = skillData[selectedJob][fb];
    var thirdSkillP = skillData[selectedJob][fc];
    if ((firstSkillP != secondSkillP) && (secondSkillP != thirdSkillP) && (thirdSkillP != firstSkillP)) {
        var currentNodestone = [firstSkillP, secondSkillP, thirdSkillP];
        if (isAlreadyIn(nodestones, currentNodestone)) {
            //alert("Node Combination Already Exists");
        }
        else {
            nodestones.push(currentNodestone);
            newNode(currentNodestone);
            photoLoadCount++;
        }

    }
    else {
        //alert("A Skill Cannot Appear in a node more than once.");
    }
}

function removePhotoResiduals(){
    document.getElementById('uploadedPhotos').innerHTML="";
}

function modalCookie(userSel){
    if(userSel == true){
        document.cookie = "nodeStoneShowModal=false; SameSite=strict";
        document.cookie = "nodeStoneVersion="+appVer + "; SameSite=strict";
    }
    else{
        document.cookie = "nodeStoneShowModal=true; SameSite=strict";
        document.cookie = "nodeStoneVersion="+appVer + "; SameSite=strict";
    }
}

function getCookie(name) {
    // Split cookie string and get all individual name=value pairs in an array //tutorialrepublic
    var cookieArr = document.cookie.split(";");
    
    // Loop through the array elements
    for(var i = 0; i < cookieArr.length; i++) {
        var cookiePair = cookieArr[i].split("=");
        
        /* Removing whitespace at the beginning of the cookie name
        and compare it with the given string */
        if(name == cookiePair[0].trim()) {
            // Decode the cookie value and return
            return decodeURIComponent(cookiePair[1]);
        }
    }
    
    // Return null if not found
    return null;
}

function validFlash(){
    flashHeader.classList.remove('greenFlash'); // reset animation
    void flashHeader.offsetWidth;
    flashHeader.classList.add('greenFlash');
}